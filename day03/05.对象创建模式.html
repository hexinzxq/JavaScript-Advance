<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>对象创建模式(5种)</title>
</head>
<body>
<!--
方式一：Object构造函数模式
  *套路：先创建空Object对象，再动态添加属性/方法
  *适用场景：起始时不确定对象内部数据
  *缺点：语句太多
-->
<!--
方式二：对象字面量模式
  *套路：使用{}创建对象，同时指定属性/方法
  *适用场景：起始时对象内部数据时确定的
  *问题：如果创建多个对象，有重复代码
-->
<!--
方式三：工厂模式
  *套路：通过工厂函数动态创建对象并返回
  *适用场景：需要创建多个对象
  *问题：对象没有一个具体的类型，都是Object类型
-->
<!--
方式四：自定义构造函数模式
  *套路：自定义构造函数，通过new创建对象
  *适用场景：需要创建多个类型确定的对象
  *问题：每个对象都有相同的数据，浪费内存
-->
<!--
方式五：构造函数+原型的组合模式
        *套路：自定义构造函数，属性在函数中初始化，方法添加到原型上
        *适用场景：需要创建多个类型确定的对象
-->
<!--<script>//这是方法一
    /*
    * 一个人：name:"Tom",age:12
    * */
    var p = new Object();
    p.name='Tom';
    p.age = 12;
    p.setName = function(name){
        this.name = name;
    }
//    测试
    p.setName("JACK");
    console.log(p.name,p.age);
</script>-->

<!--<script>//工厂模式创建对象
    function creatPerson(name,age) {//返回一个对象的函数都叫工厂函数
        var obj = {
            name: name,
            age: age,
            setName: function (name) {
                this.name = name;
            }
        }
        return obj;

        //    创建两个人
        var p1 = creatPerson("awsd", 12);
        var p2 = creatPerson("jokc", 18);
    }
</script>-->


<!--<script>//方式四
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.setName = function (name) {
        this.name = name;
    }
}

var p1 = new Person("kiki", 20);
p1.setName("klko");
console.log(p1.name,p1.age);
</script>-->


<script>//方式五
function Person(name, age) {//在构造函数中只初始化一般属性
    this.name = name;
    this.age = age;
}
Person.prototype.setName = function (name) {
        this.name = name;
}
    var p1 = new Person("hiho",15);
var p2 = new Person("biku",4);
console.log(p1,p2);
p1.setName("gigk")
p2.setName("niko")
console.log(p1.name);
console.log(p2.name);
</script>
</body>
</html>