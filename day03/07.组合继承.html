<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>组合继承</title>
</head>
<body>
<!--
方式二：借用构造函数继承（假的）
  套路：
    *1.定义父类型构造函数
    *2.定义子类型构造函数
    *3.在子类型构造函数中调用父类型构造
  关键：
    *在子类型构造函数中通过call()调用父类型构造函数
-->

<!--
★★★★★★★★
方式3：原型链+借用构造函数的组合继承
  *1.利用原型链实现对父类型对象的方法继承
  *2.利用call()借用父类型构造函数初始化相同的书香
-->
<!--<script>//方式二（这里是没有继承的）
    function Person(name,age){
        this.name = name;
        this.age = age;
    }
    function Student(name,age,price) {
        //call相当于借用了Person，this代表通过Studet创建的实例对象（没有继承的）
        Person.call(this,name,age);//相当于：this.Person(name,age);
        this.price = price;
    }
    var s = new Student('io',20,124000);
    console.log(s.name,s.age,s.price);
</script>-->

<script>//方式三(这里有继承)（★★★★★）
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.setName = function (name) {
    this.name = name;
}

function Student(name, age, price) {
    //call相当于借用了Person中的属性，this代表通过Studet创建的实例对象（没有继承的）
    //这里就是为了得到属性（★）
    Person.call(this, name, age);//相当于：this.Person(name,age);
    this.price = price;
}

Student.prototype = new Person();//为了最终能看到父类型的方法（★）
Student.prototype.constructor = Student;//修正constructer属性
Student.prototype.setPrice = function (price) {
    this.price = price;
}
var s = new Student();
s.setName("hgfy");
console.log(s.name);
</script>
</body>
</html>